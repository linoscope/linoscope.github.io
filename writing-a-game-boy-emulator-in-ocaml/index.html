<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Writing a Game Boy Emulator in OCaml - The Linoscope Machine</title><meta name=Description content="For the past few months, I have been working on a project called CAMLBOY, a Game Boy emulator that runs in the browser."><meta property="og:title" content="Writing a Game Boy Emulator in OCaml"><meta property="og:description" content="For the past few months, I have been working on a project called CAMLBOY, a Game Boy emulator that runs in the browser."><meta property="og:type" content="article"><meta property="og:url" content="https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/"><meta property="og:image" content="https://linoscope.github.io/images/camlboy-header.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-11T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-11T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://linoscope.github.io/images/camlboy-header.png"><meta name=twitter:title content="Writing a Game Boy Emulator in OCaml"><meta name=twitter:description content="For the past few months, I have been working on a project called CAMLBOY, a Game Boy emulator that runs in the browser."><meta name=application-name content="The Linoscope Machine"><meta name=apple-mobile-web-app-title content="The Linoscope Machine"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Writing a Game Boy Emulator in OCaml","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/linoscope.github.io\/writing-a-game-boy-emulator-in-ocaml\/"},"genre":"posts","wordcount":5872,"url":"https:\/\/linoscope.github.io\/writing-a-game-boy-emulator-in-ocaml\/","datePublished":"2022-01-11T00:00:00+00:00","dateModified":"2022-01-11T00:00:00+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"linoscope","logo":{"@type":"ImageObject","url":"https:\/\/linoscope.github.io\/images\/linoscope-profile-square.jpg","width":511,"height":511}},"author":{"@type":"Person","name":"linoscope"},"description":"For the past few months, I have been working on a project called CAMLBOY, a Game Boy emulator that runs in the browser."}</script></head><body header-desktop=normal header-mobile=normal><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"light"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"light"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="The Linoscope Machine">The Linoscope Machine</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/about/>About </a><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/index.xml title=RSS><i class='fas fa-rss fa-fw'></i> </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="The Linoscope Machine">The Linoscope Machine</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/about/ title>About</a><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/index.xml title=RSS><i class='fas fa-rss fa-fw'></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Writing a Game Boy Emulator in OCaml</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>linoscope</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-01-11>2022-01-11</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;5872 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;28 minutes&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/images/camlboy-header.png data-srcset="/images/camlboy-header.png, /images/camlboy-header.png 1.5x, /images/camlboy-header.png 2x" data-sizes=auto alt=/images/camlboy-header.png title="For the past few months, I have been working on a project called CAMLBOY, a Game Boy emulator that runs in the browser."></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#repository>Repository</a></li><li><a href=#screenshots>Screenshots</a></li><li><a href=#why-implement-a-game-boy-emulator-in-ocaml>Why implement a Game Boy emulator in OCaml?</a></li><li><a href=#goal-of-this-article>Goal of this article</a></li></ul></li><li><a href=#implementation>Implementation</a><ul><li><a href=#architecture-diagram>Architecture diagram</a></li><li><a href=#main-loop>Main loop</a></li><li><a href=#interface-for-readingwriting-data>Interface for reading/writing data</a><ul><li><a href=#interface-for-readingwriting-8-bit-data>Interface for reading/writing 8-bit data</a></li><li><a href=#interface-for-readingwriting-16-bit-data>Interface for reading/writing 16-bit data</a></li></ul></li><li><a href=#the-bus>The Bus</a></li><li><a href=#registers>Registers</a></li><li><a href=#the-cpu>The CPU</a><ul><li><a href=#my-initial-implementation-of-the-cpu>My initial implementation of the CPU</a></li><li><a href=#the-problem-with-the-initial-implementation-of-the-cpu>The problem with the initial implementation of the CPU</a></li><li><a href=#using-functors-to-improve-testability>Using functors to improve testability</a></li></ul></li><li><a href=#instruction-set>Instruction set</a><ul><li><a href=#define-the-instruction-set-using-variants>Define the instruction set using variants</a></li><li><a href=#problem-with-the-definition-using-variants>Problem with the definition using variants</a></li><li><a href=#gadts-to-the-rescue>GADTs to the rescue</a></li></ul></li><li><a href=#the-cartridges>The Cartridges</a></li><li><a href=#integration-tests>Integration tests</a><ul><li><a href=#what-are-test-roms>What are test ROMs</a></li><li><a href=#setting-up-the-tests>Setting up the tests</a></li><li><a href=#exploratory-programming>Exploratory programming</a></li></ul></li><li><a href=#compiling-to-javascript>Compiling to JavaScript</a></li><li><a href=#optimization>Optimization</a><ul><li><a href=#finding-bottlenecks-with-a-profiler>Finding bottlenecks with a profiler</a></li><li><a href=#removing-the-bottlenecks>Removing the bottlenecks</a></li><li><a href=#disabling-inlining>Disabling inlining</a></li></ul></li><li><a href=#some-benchmarks>Some benchmarks</a></li></ul></li><li><a href=#final-remarks>Final remarks</a><ul><li><a href=#thoughts-on-emulator-development>Thoughts on emulator development</a></li><li><a href=#things-i-liked-about-ocaml>Things I liked about OCaml</a><ul><li><ul><li><a href=#the-ecosystem>The ecosystem</a></li><li><a href=#doesnt-have-to-be-functional-to-be-useful>Doesn&rsquo;t have to be &ldquo;functional&rdquo; to be useful</a></li></ul></li></ul></li><li><a href=#things-i-didnt-like-about-ocaml>Things I didn&rsquo;t like about OCaml</a><ul><li><ul><li><a href=#the-ecosystem-1>The ecosystem</a></li><li><a href=#the-syntactical-cost-of-depending-on-abstractions>The syntactical cost of depending on abstractions</a></li></ul></li></ul></li></ul></li><li><a href=#recommended-materials>Recommended Materials</a><ul><li><a href=#about-ocaml>About OCaml</a></li><li><a href=#about-game-boy>About Game Boy</a></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=introduction>Introduction</h1><p>For the past few months, I have been working on a project called <em>CAMLBOY</em>, a Game Boy emulator written in OCaml that runs in the browser. You can try it out on the following demo page:</p><p><strong><a href=https://linoscope.github.io/CAMLBOY/ target=_blank rel="noopener noreffer">Demo Page</a></strong></p><p>I included several homebrew ROMs in the demo, so please try them out (I recommend <em>Bouncing ball</em> and <em>Rocket Man Demo</em>). You can also play with it in your mobile browser as it runs at 60 FPS on recent smartphones.</p><h2 id=repository>Repository</h2><p>You can find the repository here:</p><p><strong><a href=https://github.com/linoscope/CAMLBOY target=_blank rel="noopener noreffer">https://github.com/linoscope/CAMLBOY</a></strong></p><script async defer src=https://buttons.github.io/buttons.js></script><a class=github-button href=https://github.com/linoscope/CAMLBOY data-icon=octicon-star data-size=large data-show-count=true aria-label="Star linoscope/CAMLBOY on GitHub">Star</a><a class=github-button href=https://github.com/linoscope/CAMLBOY/fork data-icon=octicon-repo-forked data-size=large data-show-count=true aria-label="Fork linoscope/CAMLBOY on GitHub">Fork</a><h2 id=screenshots>Screenshots</h2><div align=center><img src=/images/pokemon-vs-green.gif alt="pokemon vs greef gif" title=pokemon-vs-green></div><div align=center><img src=/images/zelda-opening.gif alt=zelda-gif title=zelda-gif>
<img src=/images/kirby-opening.gif alt=kirby-gif title=kirby-gif>
<img src=/images/tetris-opening.gif alt=tetris-gif title=tetris-gif>
<img src=/images/donkykong-opening.gif alt=donkykong-gif title=donkykong-gif></div><h2 id=why-implement-a-game-boy-emulator-in-ocaml>Why implement a Game Boy emulator in OCaml?</h2><p>Have you ever felt like the following when learning a new programming language?</p><ul><li>You can write simple program snippets but <strong>you don&rsquo;t know how to write medium/large scale code<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></strong>.</li><li>You have studied <strong>advanced language features<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></strong> and have a rough understanding of how they work, but <strong>you don&rsquo;t know how to use them in practice</strong>.</li></ul><p>These were exactly my thoughts when I started to study OCaml seriously a few months ago. I understood the basics of the language by reading books and implementing simple algorithms, but the above two &ldquo;don&rsquo;t know"s prevented me from feeling like I could <em>really</em> write OCaml. I knew that the only way to get out of this situation was practice, so I started looking for a project to work on.</p><p>I choose a Game Boy emulator as the project for the following reasons:</p><ul><li>It has clear specifications, so there is no need to think about what to implement.</li><li>It is complex enough that it cannot be completed in a few days or weeks.</li><li>It is not so complex that it can&rsquo;t be completed in a few months.</li><li>I have fond childhood memories of playing the Game Boy.</li></ul><p>I set the following goals for the emulator:</p><ul><li>Write code with an emphasis on readability and maintainability.</li><li>Compile to JavaScript using <a href=https://github.com/ocsigen/js_of_ocaml target=_blank rel="noopener noreffer">js_of_ocaml</a> and run it in the browser.</li><li>Achieve playable FPS in the smartphone browser.</li><li>Implement some benchmarks and compare various compiler backends<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</li></ul><h2 id=goal-of-this-article>Goal of this article</h2><p>This article aims to take you through the journey of creating a Game Boy emulator in OCaml.</p><p>This article is for you if you are interested in what it is like to</p><ul><li>Implement a Game Boy emulator.</li><li>Implement a middle-scale project in OCaml.</li><li>Use advanced features of OCaml in practice.</li></ul><p>We will cover things like</p><ul><li>Overview of the Game Boy architecture.</li><li>How to structure your code in a testable and reusable way.</li><li>How to use functors, GADTs, and first-class modules in practice.</li><li>How to find bottlenecks and improve performance.</li><li>General thoughts on OCaml.</li></ul><p>We will not cover things like</p><ul><li>Basic OCaml syntax.</li><li>Details of the Game Boy architecture.</li></ul><p>You can find materials about these uncovered topics in the <a href=#recommended-materials rel>Recommended Materials</a> section.</p><h1 id=implementation>Implementation</h1><h2 id=architecture-diagram>Architecture diagram</h2><p>A schematic diagram of CAMLBOY looks like this:<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p><div align=center><img src=/images/camlboy-architecture.png alt="camlboy architecture" title=camlboy-architecture></div><p>I&rsquo;ll explain the details as needed, but in a nutshell:</p><ul><li>The CPU/timer/GPU operates at a fixed rate according to a clock.</li><li>The bus sits between the CPU and various hardware modules and routes data reads/writes based on the given address. For example, writes to address <code>0xFFFF</code> is routed to the interrupt controller and enables/disables interrupts based on the written value.</li><li>Hardware modules connected to the bus implement the interface <code>Addressable_intf.S</code> (which I will explain later)</li><li>The bus implements the interface <code>Word_addressable_intf.S</code> (which I will explain later)</li><li>There are various types of cartridges.</li><li>The timer, GPU, serial port, and joypad can request interrupts. The interrupt controller will notify the requested interrupt to the CPU (further explanation of interrupts is omitted in this article).</li></ul><h2 id=main-loop>Main loop</h2><p>The main loop is responsible for progressing the clocked hardware modules (highlighted in red below) in a synchronized way.</p><div align=center><img src=/images/camlboy-architecture-clocked.png alt="camlboy architecture clocked" title=camlboy-architecture-clocked></div><p>In real hardware, the CPU/timer/GPU share the same hardware clock, so they naturally run in a synchronized state. On the other hand, the emulator is just a sequential execution loop, so we need to devise a way to reproduce the synchronization between these components. To do so, I implemented the main loop to contain the following steps:</p><ol><li>Let the CPU execute one instruction and keep track of the number of cycles consumed as a result.</li><li>Advance the timer by the number of cycles consumed by the CPU.</li><li>Advance the GPU by the number of cycles consumed by the CPU.</li></ol><p>We sometimes call this the <em>catch up method</em> because it makes the timer and GPU &ldquo;catch up&rdquo; with the CPU. Here is the implementation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* camlboy.ml *)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>run_instruction</span> <span class=n>t</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>mcycles</span> <span class=o>=</span> <span class=nn>Cpu</span><span class=p>.</span><span class=n>run_instruction</span> <span class=n>t</span><span class=o>.</span><span class=n>cpu</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=nn>Timer</span><span class=p>.</span><span class=n>run</span> <span class=n>t</span><span class=o>.</span><span class=n>timer</span> <span class=o>~</span><span class=n>mcycles</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=nn>Gpu</span><span class=p>.</span><span class=n>run</span> <span class=n>t</span><span class=o>.</span><span class=n>gpu</span> <span class=o>~</span><span class=n>mcycles</span>
</span></span></code></pre></div><h2 id=interface-for-readingwriting-data>Interface for reading/writing data</h2><p>We will look at some basic interfaces used throughout the emulator.</p><h3 id=interface-for-readingwriting-8-bit-data>Interface for reading/writing 8-bit data</h3><p>First, let&rsquo;s look at the interface for reading/writing 8-bit data used in the red line below.</p><div align=center><img src=/images/camlboy-architecture-addressable.png alt="camlboy architecture addressable" title=camlboy-architecture-addressable></div><p>The Bus can read and write 8-bit data from various hardware modules such as GPU and RAM. Since we will be implementing many modules that can read and write 8-bit data, we&rsquo;d like to share their interface in some form.</p><p>With OOP, you would</p><ol><li>Write an interface (<code>public interface A {...}</code> in Java).</li><li>Implement it (<code>implements A</code> in Java).</li></ol><p>With OCaml, you can</p><ol><li>Write a signature (<code>module type S = sig ... end</code>).</li><li>Include it (<code>include S with type t := t </code>).</li></ol><p>Following these steps, we define the signature <code>Addressable_intf.S</code> as below<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* addressable_intf.mli *)</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>S</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=c>(* reads 8-bit data from address addr *)</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>read_byte</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=o>-&gt;</span> <span class=n>uint8</span>
</span></span><span class=line><span class=cl>  <span class=c>(* writes 8-bit data to address addr *)</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>write_byte</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>addr</span><span class=o>:</span><span class=n>uint16</span> <span class=o>-&gt;</span> <span class=n>data</span><span class=o>:</span><span class=n>uint8</span> <span class=o>-&gt;</span> <span class=kt>unit</span>
</span></span><span class=line><span class=cl>  <span class=c>(* returns true if it accepts reads/writes from addr and returns false if it can not *)</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>accepts</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>Then we include <code>Addressable_intf.S</code> in the interface files of modules that provide 8-bit reads/writes. For example, the RAM module&rsquo;s interface file <code>ram.mli</code> looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* ram.mli *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=k>include</span> <span class=nn>Addressable_intf</span><span class=p>.</span><span class=nc>S</span> <span class=k>with</span> <span class=k>type</span> <span class=n>t</span> <span class=o>:=</span> <span class=n>t</span>
</span></span></code></pre></div><p>In the same way, <code>gpu.mli</code>, <code>joypad.mli</code>, <code>timer.mli</code>, etc, include <code>Addressable_intf.S</code>.</p><p><strong>Note</strong></p><p>The <code>with type t := t</code> in the above code may need explanation. In general, <code>A with type t := s</code> replaces <code>t</code> in the signature <code>A</code> with <code>s</code>. So <code>include Addressable_intfS with type t := t</code> means:</p><p><em>replace type <code>t</code> in <code>Addressable_intfS</code> with type <code>t</code> in <code>Ram</code>, and then <code>include</code> (&ldquo;expand&rdquo; it here)</em>.</p><p>In other words, the above <code>ram.mli</code> is the same as the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* ram.mli *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=c>(* include Addressable_intf.S with type t := t will be &#34;expanded&#34; as the following *)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>read_byte</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=o>-&gt;</span> <span class=n>uint8</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>write_byte</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>addr</span><span class=o>:</span><span class=n>uint16</span> <span class=o>-&gt;</span> <span class=n>data</span><span class=o>:</span><span class=n>uint8</span> <span class=o>-&gt;</span> <span class=kt>unit</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>accepts</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=o>-&gt;</span> <span class=kt>bool</span>
</span></span></code></pre></div><h3 id=interface-for-readingwriting-16-bit-data>Interface for reading/writing 16-bit data</h3><p>Next, let&rsquo;s look at the interface for reading/writing 16-bit data used in the red line below.</p><div align=center><img src=/images/camlboy-architecture-word-addressable.png alt="camlboy architecture word addressable" title=camlboy-architecture-word-addressable></div><p>Between the CPU and the bus, in addition to 8-bit data, 16-bit data can also be read/written. To express this, it would be nice if we could somehow &ldquo;extend&rdquo; the interface for 8-bit data read/write (<code>Addressable_intf.S</code>) with 16-bit read/write functions.</p><p>In OOP, you would</p><ol><li>Inherit the interface (<code>extends A</code> in Java).</li></ol><p>With OCaml, you can</p><ol><li>Include the signature (<code>include A with type t := t </code>).</li></ol><p>Hence to extend <code>Addressable_intf.S</code> with 16-bit reads/writes, we can</p><ol><li>Define a signature called <code>Word_addressable_intf.S</code>.</li><li>Include <code>Addressable_intf.S</code></li><li>Add additional functions (<code>read_word</code> and <code>write_word</code>)</li></ol><p>Resulting in this definition:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* word_addressable_intf.ml *)</span>
</span></span><span class=line><span class=cl><span class=c>(** Interface that provide 16-bit read/write in addition to 8-bit read/write *)</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=k>type</span> <span class=nc>S</span> <span class=o>=</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=k>include</span> <span class=nn>Addressable_intf</span><span class=p>.</span><span class=nc>S</span> <span class=k>with</span> <span class=k>type</span> <span class=n>t</span> <span class=o>:=</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=c>(* 16-bit reads/writes *)</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>read_word</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=o>-&gt;</span> <span class=n>uint16</span>
</span></span><span class=line><span class=cl>  <span class=k>val</span> <span class=n>write_word</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>addr</span><span class=o>:</span><span class=n>uint16</span> <span class=o>-&gt;</span> <span class=n>data</span><span class=o>:</span><span class=n>uint16</span> <span class=o>-&gt;</span> <span class=kt>unit</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><h2 id=the-bus>The Bus</h2><p>Let&rsquo;s take a look at the implementation of the bus, highlighted in the red box below.</p><div align=center><img src=/images/camlboy-architecture-bus.png alt="camlboy architecture bus" title=camlboy-architecture-bus></div><p>The bus sits between the CPU and various hardware modules, and routes data reads/writes based on the given address. For example, the bus routs read/write to address <code>0xC000</code> to the RAM. You can find the full memory map <a href=https://gbdev.io/pandocs/Memory_Map.html target=_blank rel="noopener noreffer">here</a></p><p>Using the <code>Word_addressable_intf.S</code> implemented above, we can define the interface of the bus module (<code>bus.mli</code>) as the following.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* bus.mli *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>create</span> <span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>gpu</span><span class=o>:</span><span class=nn>Gpu</span><span class=p>.</span><span class=n>t</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>timer</span><span class=o>:</span><span class=nn>Timer</span><span class=p>.</span><span class=n>t</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>wram</span><span class=o>:</span><span class=nn>Ram</span><span class=p>.</span><span class=n>t</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>  <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>include</span> <span class=nn>Word_addressable_intf</span><span class=p>.</span><span class=nc>S</span> <span class=k>with</span> <span class=k>type</span> <span class=n>t</span> <span class=o>:=</span> <span class=n>t</span>
</span></span></code></pre></div><p>Then, we can implement the bus (<code>bus.ml</code>) like below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* bus.ml *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>gpu</span>   <span class=o>:</span> <span class=nn>Gpu</span><span class=p>.</span><span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>timer</span> <span class=o>:</span> <span class=nn>Timer</span><span class=p>.</span><span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>wram</span>  <span class=o>:</span> <span class=nn>Ram</span><span class=p>.</span><span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* takes the modules connected to the bus as its argument *)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>create</span> <span class=o>~</span><span class=n>gpu</span> <span class=o>~</span><span class=n>timer</span> <span class=o>~</span><span class=n>wram</span> <span class=o>...</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>gpu</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>timer</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>wram</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>read_byte</span> <span class=n>t</span> <span class=n>addr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=c>(* routes the data read to the appropriate module based on the given address *)</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>addr</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=k>when</span> <span class=nn>Gpu</span><span class=p>.</span><span class=n>accepts</span> <span class=n>t</span><span class=o>.</span><span class=n>gpu</span> <span class=n>addr</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nn>Gpu</span><span class=p>.</span><span class=n>read_byte</span> <span class=n>t</span><span class=o>.</span><span class=n>gpu</span> <span class=n>addr</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=k>when</span> <span class=nn>Timer</span><span class=p>.</span><span class=n>accepts</span> <span class=n>t</span><span class=o>.</span><span class=n>timer</span> <span class=n>addr</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nn>Timer</span><span class=p>.</span><span class=n>read_byte</span> <span class=n>t</span><span class=o>.</span><span class=n>timer</span> <span class=n>addr</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>_</span> <span class=k>when</span> <span class=nn>Ram</span><span class=p>.</span><span class=n>accepts</span> <span class=n>t</span><span class=o>.</span><span class=n>wram</span> <span class=n>addr</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nn>Ram</span><span class=p>.</span><span class=n>read_byte</span> <span class=n>t</span><span class=o>.</span><span class=n>wram</span> <span class=n>addr</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>read_word</span> <span class=n>t</span> <span class=n>addr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=c>(* The read_word function archives 16-bit reads by calling read_byte twice.
</span></span></span><span class=line><span class=cl><span class=c>     The actual hardware also achieves 16-bit read/write by conducting 8-bit read/write twice. *)</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>lo</span> <span class=o>=</span> <span class=nn>Uint8</span><span class=p>.</span><span class=n>to_int</span> <span class=o>(</span><span class=n>read_byte</span> <span class=n>t</span> <span class=n>addr</span><span class=o>)</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>hi</span> <span class=o>=</span> <span class=nn>Uint8</span><span class=p>.</span><span class=n>to_int</span> <span class=o>(</span><span class=n>read_byte</span> <span class=n>t</span> <span class=nn>Uint16</span><span class=p>.</span><span class=o>(</span><span class=n>succ</span> <span class=n>addr</span><span class=o>))</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=o>(</span><span class=n>hi</span> <span class=ow>lsl</span> <span class=mi>8</span><span class=o>)</span> <span class=o>+</span> <span class=n>lo</span> <span class=o>|&gt;</span> <span class=nn>Uint16</span><span class=p>.</span><span class=n>of_int</span>
</span></span></code></pre></div><h2 id=registers>Registers</h2><p>Let&rsquo;s take a look at the implementation of registers, highlighted in the red box below.</p><div align=center><img src=/images/camlboy-architecture-registers.png alt="camlboy architecture registers" title=camlboy-architecture-registers></div><p>The Game Boy&rsquo;s CPU has eight 8-bit registers, <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code>, <code>H</code>, and <code>L</code>. These 8-bit registers can be combined to be used as 16-bit registers <code>AF</code>, <code>BC</code>, <code>DE</code>, and <code>HL</code>. Below is the interface of the <code>Registers</code> module (implementation is omitted):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* registers.mli *)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=c>(* identifiers of the 8-bit registers *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>r</span> <span class=o>=</span> <span class=nc>A</span> <span class=o>|</span> <span class=nc>B</span> <span class=o>|</span> <span class=nc>C</span> <span class=o>|</span> <span class=nc>D</span> <span class=o>|</span> <span class=nc>E</span> <span class=o>|</span> <span class=nc>F</span> <span class=o>|</span> <span class=nc>H</span> <span class=o>|</span> <span class=nc>L</span>
</span></span><span class=line><span class=cl><span class=c>(* identifiers for the 16-bit registers *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>rr</span> <span class=o>=</span> <span class=nc>AF</span> <span class=o>|</span> <span class=nc>BC</span> <span class=o>|</span> <span class=nc>DE</span> <span class=o>|</span> <span class=nn>HL</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* read/write functions for the above registers *)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>read_r</span>   <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span>  <span class=n>r</span> <span class=o>-&gt;</span> <span class=n>uint8</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>write_r</span>  <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span>  <span class=n>r</span> <span class=o>-&gt;</span> <span class=n>uint8</span> <span class=o>-&gt;</span> <span class=kt>unit</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>read_rr</span>  <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>rr</span> <span class=o>-&gt;</span> <span class=n>uint16</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>write_rr</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>rr</span> <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=o>-&gt;</span> <span class=kt>unit</span>
</span></span></code></pre></div><h2 id=the-cpu>The CPU</h2><p>Let&rsquo;s take a look at the implementation of the CPU, highlighted in the red box below.</p><div align=center><img src=/images/camlboy-architecture-cpu.png alt="camlboy architecture cpu" title=camlboy-architecture-cpu></div><h3 id=my-initial-implementation-of-the-cpu>My initial implementation of the CPU</h3><p>Below is my initial implementation of the CPU. Details of the <code>execute</code> function are omitted here and will be discussed when implementing the instruction set.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* cpu.mli *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>create</span> <span class=o>:</span> <span class=n>bus</span><span class=o>:</span><span class=nn>Bus</span><span class=p>.</span><span class=n>t</span> <span class=o>-&gt;</span> <span class=n>registers</span><span class=o>:</span><span class=nn>Registers</span><span class=p>.</span><span class=n>t</span> <span class=o>-&gt;</span> <span class=o>...</span> <span class=o>-&gt;</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>run_instruction</span> <span class=o>:</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=kt>int</span> <span class=c>(* returns the # of cycles consumed *)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* cpu.ml *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>registers</span>  <span class=o>:</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>bus</span>        <span class=o>:</span> <span class=nn>Bus</span><span class=p>.</span><span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>mutable</span> <span class=n>pc</span> <span class=o>:</span> <span class=n>uint16</span><span class=o>;</span> <span class=c>(* Program counter *)</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* Initializes the CPU by passing it&#39;s dependencies *)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>create</span> <span class=o>~</span><span class=n>bus</span> <span class=o>~</span><span class=n>registers</span> <span class=o>...</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>bus</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>registers</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* Omitted for now. *)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>execute</span> <span class=n>t</span> <span class=n>inst</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* Fetches, decodes, and executes an instruction *)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>run_instruction</span> <span class=n>t</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>inst</span> <span class=o>=</span> <span class=nn>Fetch_and_decode</span><span class=p>.</span><span class=n>f</span> <span class=n>t</span><span class=o>.</span><span class=n>bus</span> <span class=o>~</span><span class=n>pc</span><span class=o>:</span><span class=n>t</span><span class=o>.</span><span class=n>pc</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>execute</span> <span class=n>t</span> <span class=n>inst</span>
</span></span></code></pre></div><h3 id=the-problem-with-the-initial-implementation-of-the-cpu>The problem with the initial implementation of the CPU</h3><p>The above implementation of the CPU works, but there is one problem â€” it is hard to test. The following diagram illustrates why:</p><div align=center><img src=/images/camlboy-architecture-simplified.png alt="camlboy architecture simplified" title=camlboy-architecture-simplified></div><p>Notice that the bus has many dependencies on various modules. These dependencies make it hard to instantiate the CPU in our unit tests. Furthermore, it is impossible to instantiate the CPU until we implement the bus and all the connected modules, which would be pretty later on in the development process.</p><p>To make the CPU testable, we want to abstract away the implementation of the bus from the CPU. Once we do this, we can swap the bus with a mock implementation, as illustrated below:</p><div align=center><img src=/images/camlboy-architecture-mocked-bus.png alt="camlboy architecture mocked bus" title=camlboy-architecture-mocked-bus></div><p>In OCaml, you can achieve such abstraction of implementation using <em><strong>functors</strong></em>.</p><h3 id=using-functors-to-improve-testability>Using functors to improve testability</h3><p>I have reimplemented the CPU using functors like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* cpu.mli *)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* We can now &#34;inject&#34; different implementations of the Bus via this functor argument *)</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>Make</span> <span class=o>(</span><span class=nc>Bus</span> <span class=o>:</span> <span class=nn>Word_addressable_intf</span><span class=p>.</span><span class=nc>S</span><span class=o>)</span> <span class=o>:</span> <span class=k>sig</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* cpu.ml *)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>Make</span> <span class=o>(</span><span class=nc>Bus</span> <span class=o>:</span> <span class=nn>Word_addressable_intf</span><span class=p>.</span><span class=nc>S</span><span class=o>)</span> <span class=o>=</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl>  <span class=k>type</span> <span class=n>t</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>registers</span>  <span class=o>:</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>bus</span>        <span class=o>:</span> <span class=nn>Bus</span><span class=p>.</span><span class=n>t</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>pc</span> <span class=o>:</span> <span class=n>uint16</span><span class=o>;</span> <span class=c>(* Program counter *)</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><p>Thanks to this change, we can use a mock implementation of the bus to instantiate the CPU in our unit tests, as illustrated below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* test_cpu.ml *)</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=c>(* Mock_bus is a simple implementation of `Word_addressable_intf.S`
</span></span></span><span class=line><span class=cl><span class=c>   which is implemented using a single byte array. *)</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>Cpu</span> <span class=o>=</span> <span class=nn>Cpu</span><span class=p>.</span><span class=nc>Make</span><span class=o>(</span><span class=nc>Mock_bus</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>cpu</span> <span class=o>=</span> <span class=nn>Cpu</span><span class=p>.</span><span class=n>create</span> <span class=o>~</span><span class=n>bus</span><span class=o>:(</span><span class=nn>Mock_bus</span><span class=p>.</span><span class=n>create</span> <span class=o>~</span><span class=n>size</span><span class=o>:</span><span class=mh>0xFF</span><span class=o>)</span> <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span></code></pre></div><h2 id=instruction-set>Instruction set</h2><p>Let&rsquo;s encode Game Boy&rsquo;s instruction in OCaml.</p><p>The instruction set of Game Boy consists of</p><ul><li><em>8-bit instructions</em>: takes 8-bit values (8-bit registers, 8-bit immediate values, etc.) as arguments.</li><li><em>16-bit instructions</em>: takes 16-bit values (16-bit registers, 16-bit immediate values, etc.) as arguments.</li></ul><p>For example, there are two versions of addition as shown below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=c1># 8-bit version
</span></span></span><span class=line><span class=cl><span class=c1># Adds the 8-bit `A` register and `0x12`, then stores the result in the `A` register
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ADD8</span><span class=w> </span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=n>x12</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1># 16-bit version
</span></span></span><span class=line><span class=cl><span class=c1># adds the 16-bit `AF` register and `0x1234`, then stores the result in the `AF` register
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ADD16</span><span class=w> </span><span class=n>AF</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=n>x1234</span><span class=w>
</span></span></span></code></pre></div><p>Now, how should we define such an instruction set in OCaml?</p><h3 id=define-the-instruction-set-using-variants>Define the instruction set using variants</h3><p>As a first attempt, I represented the instructions and their arguments as variants, as shown below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* instruction.ml *)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* Instruction arguments definied using variants *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>arg</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Immediate8</span>  <span class=k>of</span> <span class=n>uint8</span>   <span class=c>(*  8-bit value *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Immediate16</span> <span class=k>of</span> <span class=n>uint16</span> <span class=c>(* 16-bit value *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>R</span>           <span class=k>of</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>r</span>      <span class=c>(*  8-bit register *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RR</span>          <span class=k>of</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>rr</span>    <span class=c>(* 16-bit register *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* Instructions *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>ADD8</span>  <span class=k>of</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>arg</span> <span class=c>(*  8-bit version of ADD *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>ADD16</span> <span class=k>of</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>arg</span> <span class=c>(* 16-bit version of ADD *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>...</span>
</span></span></code></pre></div><p>But I soon noticed that this approach does not work.</p><h3 id=problem-with-the-definition-using-variants>Problem with the definition using variants</h3><p>Why does this approach not work? The problem arises when we try to &ldquo;consume&rdquo; the instruction set in the <code>execute</code> function, as shown below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* cpu.ml *)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* Takes a single instruction and executes it. *)</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>execute</span> <span class=n>t</span> <span class=o>(</span><span class=n>inst</span> <span class=o>:</span> <span class=nn>Instruction</span><span class=p>.</span><span class=n>t</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>read_arg</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=c>(* fetch values stored in the given argument *)</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Immidiate8</span>  <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Immediate16</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>R</span>  <span class=n>r</span>          <span class=o>-&gt;</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>read_r</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>RR</span> <span class=n>rr</span>         <span class=o>-&gt;</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>read_rr</span> <span class=n>rr</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>inst</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Add8</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>y</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c>(* Fetches the value stored in the arguments x and y adds them. *)</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>sum</span> <span class=o>=</span> <span class=nn>Uint8</span><span class=p>.</span><span class=n>add</span> <span class=o>(</span><span class=n>read_arg</span> <span class=n>x</span><span class=o>)</span> <span class=o>(</span><span class=n>read_arg</span> <span class=n>y</span><span class=o>)</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Add16</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>y</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>sum</span> <span class=o>=</span> <span class=nn>Uint16</span><span class=p>.</span><span class=n>add</span> <span class=o>(</span><span class=n>read_arg</span> <span class=n>x</span><span class=o>)</span> <span class=o>(</span><span class=n>read_arg</span> <span class=n>y</span><span class=o>)</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>run_instruction</span> <span class=n>t</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>inst</span> <span class=o>=</span> <span class=nn>Fetch_and_decode</span><span class=p>.</span><span class=n>f</span> <span class=n>t</span><span class=o>.</span><span class=n>bus</span> <span class=o>~</span><span class=n>pc</span><span class=o>:</span><span class=n>t</span><span class=o>.</span><span class=n>pc</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>execute</span> <span class=n>t</span> <span class=n>inst</span>
</span></span></code></pre></div><p>I have extracted the <code>read_arg</code> function below to understand the problem. Notice that the return value of the entire function cannot be uniquely determined. This is because the return type of the match expression changes depending on which constructor it matches, as highlighted in the comments.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl>  <span class=c>(* What is the type of the return value? *)</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>read_arg</span> <span class=o>:</span> <span class=nn>Instruction</span><span class=p>.</span><span class=n>arg</span> <span class=o>-&gt;</span> <span class=o>???</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>R</span> <span class=n>r</span>  <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=c>(* fetches the value of 8-bit register. *)</span>
</span></span><span class=line><span class=cl>      <span class=c>(* returns uint8 in this case. *)</span>
</span></span><span class=line><span class=cl>      <span class=nn>Registers</span><span class=p>.</span><span class=n>read_r</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>RR</span> <span class=n>r</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=c>(* fetches the value of 16-bit register. *)</span>
</span></span><span class=line><span class=cl>      <span class=c>(* returns uint16 in this case. *)</span>
</span></span><span class=line><span class=cl>      <span class=nn>Registers</span><span class=p>.</span><span class=n>read_rr</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span>
</span></span></code></pre></div><p>At this point, I remembered <em><strong>GADT</strong></em> (<em><strong>Generalized Algebraic Data Type</strong></em>), a language feature that I had studied before but never really felt comfortable with.</p><h3 id=gadts-to-the-rescue>GADTs to the rescue</h3><p>Below is the redefined instruction set that uses GADTs. Notice that the definition of the <code>arg</code> type looks different from the previous variant definition.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* instruction.ml *)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* Instruction arguments definied using GADTs *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=o>_</span> <span class=n>arg</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Immediate8</span>  <span class=o>:</span> <span class=n>uint8</span>        <span class=o>-&gt;</span> <span class=n>uint8</span>  <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Immediate16</span> <span class=o>:</span> <span class=n>uint16</span>       <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>R</span>           <span class=o>:</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>r</span>  <span class=o>-&gt;</span> <span class=n>uint8</span>  <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RR</span>          <span class=o>:</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>rr</span> <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>(* Instructions *)</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>ADD8</span>  <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>ADD16</span> <span class=k>of</span> <span class=n>uint16</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=o>...</span>
</span></span></code></pre></div><p>To understand the meaning of this definition, let&rsquo;s focus on the third line of the <code>arg</code> type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>R</span> <span class=o>:</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>r</span> <span class=o>-&gt;</span> <span class=n>uint8</span>  <span class=n>arg</span>
</span></span></code></pre></div><p>The argument type of the constructor (<code>Registers.r</code> in <code>Registers.r -> uint8 arg</code>) has the same functionality as the <code>of Registers.r</code> in the variant definition. It changes the <strong>type of the value you <em>get</em> in the pattern match based on the constructor</strong>. In the below match statement, notice that the type of value we get in the match statement (type of <code>r</code> and <code>rr</code>) is different depending on the constructor we match. This is possible because the argument type of the constructor is different.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=k>let</span> <span class=n>read_arg</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>R</span>   <span class=n>r</span> <span class=o>-&gt;</span> <span class=o>..</span> <span class=c>(* type of r is Registers.r *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RR</span> <span class=n>rr</span> <span class=o>-&gt;</span> <span class=o>..</span> <span class=c>(* type of rr is Registers.rr *)</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span></code></pre></div><p>Then what does the return type of the constructor (<code>uint8 arg</code> in <code>Registers.r -> uint8 arg</code>) represent? There seems to be nothing corresponding to this in the variant definition. The answer is: it changes <strong>type of the value you <em>return</em> in the pattern match based on the constructor</strong>. Take a look at the below match statement. Notice that the type of value we return in the match statement is different depending on the constructor we match. This is possible because the return type of the constructor is different.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=k>let</span> <span class=n>read_arg</span> <span class=o>=</span> <span class=k>function</span>
</span></span><span class=line><span class=cl>  <span class=o>..</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>R</span>   <span class=n>r</span> <span class=o>-&gt;</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>read_r</span> <span class=n>r</span>   <span class=c>(* returns uint8 *)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RR</span> <span class=n>rr</span> <span class=o>-&gt;</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>read_rr</span> <span class=n>rr</span> <span class=c>(* returns uint16 *)</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span></code></pre></div><p>In summary, <strong>variants can parametrize the type of values we get in the match statement</strong>, while <strong>GATDs can also parameterize the type of the value we return in the match statement</strong>. In this sense, GADTs are more &ldquo;general&rdquo; than variants, which I guess is where the name &ldquo;Generalized&rdquo; Algebraic Data Type comes from.</p><p>Using the newly defined <code>Instruction.arg</code>, which uses GADTs, we can write <code>execute</code> as below. The type <code>'a Instruction.arg -> 'a</code> of <code>read_arg</code> indicates that the return type changes based on the type of the given constructor.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=k>let</span> <span class=n>execute</span> <span class=n>t</span> <span class=o>(</span><span class=n>inst</span> <span class=o>:</span> <span class=nn>Instruction</span><span class=p>.</span><span class=n>t</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>read_arg</span> <span class=o>:</span> <span class=k>type</span> <span class=n>a</span><span class=o>.</span> <span class=n>a</span> <span class=nn>Instruction</span><span class=p>.</span><span class=n>arg</span> <span class=o>-&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=k>fun</span> <span class=n>arg</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>match</span> <span class=n>arg</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Immediate8</span>  <span class=n>n</span> <span class=o>-&gt;</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=nc>Immediate16</span> <span class=n>n</span> <span class=o>-&gt;</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>inst</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Add8</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>y</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>sum</span> <span class=o>=</span> <span class=nn>Uint8</span><span class=p>.</span><span class=n>add</span> <span class=o>(</span><span class=n>read_arg</span> <span class=n>x</span><span class=o>)</span> <span class=o>(</span><span class=n>read_arg</span> <span class=n>y</span><span class=o>)</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Add16</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>y</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=n>sum</span> <span class=o>=</span> <span class=nn>Uint16</span><span class=p>.</span><span class=n>add</span> <span class=o>(</span><span class=n>read_arg</span> <span class=n>x</span><span class=o>)</span> <span class=o>(</span><span class=n>read_arg</span> <span class=n>y</span><span class=o>)</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>For refrence, here is the full instruction set defined using GADTs (click to expand):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=k>type</span> <span class=o>_</span> <span class=n>arg</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Immediate8</span>  <span class=o>:</span> <span class=n>uint8</span>        <span class=o>-&gt;</span> <span class=n>uint8</span>  <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Immediate16</span> <span class=o>:</span> <span class=n>uint16</span>       <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Direct8</span>     <span class=o>:</span> <span class=n>uint16</span>       <span class=o>-&gt;</span> <span class=n>uint8</span>  <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Direct16</span>    <span class=o>:</span> <span class=n>uint16</span>       <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>R</span>           <span class=o>:</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>r</span>  <span class=o>-&gt;</span> <span class=n>uint8</span>  <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RR</span>          <span class=o>:</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>rr</span> <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RR_indirect</span> <span class=o>:</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>rr</span> <span class=o>-&gt;</span> <span class=n>uint8</span>  <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>FF00_offset</span> <span class=o>:</span> <span class=n>uint8</span>        <span class=o>-&gt;</span> <span class=n>uint8</span>  <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>FF00_C</span>      <span class=o>:</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>HL_inc</span>      <span class=o>:</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>HL_dec</span>      <span class=o>:</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SP</span>          <span class=o>:</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SP_offset</span>   <span class=o>:</span> <span class=n>int8</span>         <span class=o>-&gt;</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>condition</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>None</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>NZ</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Z</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>NC</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>C</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>LD8</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>LD16</span>  <span class=k>of</span> <span class=n>uint16</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>ADD8</span>  <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>ADD16</span> <span class=k>of</span> <span class=n>uint16</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>ADDSP</span> <span class=k>of</span> <span class=n>int8</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>ADC</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SUB</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SBC</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>AND</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>OR</span>    <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>XOR</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>CP</span>    <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>INC</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>INC16</span> <span class=k>of</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>DEC</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>DEC16</span> <span class=k>of</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SWAP</span>  <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>DAA</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>CPL</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>CCF</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SCF</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>NOP</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>HALT</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>STOP</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>DI</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>EI</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RLCA</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RLA</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RRCA</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RRA</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RLC</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RL</span>    <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RRC</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RR</span>    <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SLA</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SRA</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SRL</span>   <span class=k>of</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>BIT</span>   <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>SET</span>   <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RES</span>   <span class=k>of</span> <span class=kt>int</span> <span class=o>*</span> <span class=n>uint8</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>PUSH</span>  <span class=k>of</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>rr</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>POP</span>   <span class=k>of</span> <span class=nn>Registers</span><span class=p>.</span><span class=n>rr</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>JP</span>    <span class=k>of</span> <span class=n>condition</span> <span class=o>*</span> <span class=n>uint16</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>JR</span>    <span class=k>of</span> <span class=n>condition</span> <span class=o>*</span> <span class=n>int8</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>CALL</span>  <span class=k>of</span> <span class=n>condition</span> <span class=o>*</span> <span class=n>uint16</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RST</span>   <span class=k>of</span> <span class=n>uint16</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RET</span>   <span class=k>of</span> <span class=n>condition</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>RETI</span>
</span></span></code></pre></div><h2 id=the-cartridges>The Cartridges</h2><p>Let&rsquo;s look at the implementation of the cartridges, highlighted in the red box below.</p><div align=center><img src=/images/camlboy-architecture-cartridge.png alt="camlboy architecture cartridge" title=camlboy-architecture-cartridge></div><p>You might think that Game Boy cartridges are just a ROM (read-only memory) that stores game data/code, but this is not the case. Many Game Boy cartridges contain hardware components to enhance the Game Boy&rsquo;s limited functionality. For example, while ROM_ONLY type cartridges (such as Tetris) only include the ROM that stores the game data/code, MBC3 type cartridges (such as PokÃ©mon Red) contain independent RAM and timers in addition to the ROM.</p><p>Since each cartridge type has separate functionality, we will implement each cartridge type as individual modules. Therefore, we need a mechanism to select a module according to the cartridge type at runtime.</p><p><strong><em>First-class modules</em></strong> are helpful for this kind of &ldquo;runtime module selection&rdquo;. As shown below, you can write <code>Detect_cartridge.f</code> that returns a first-class module based on the cartridge type. We will omit the implementation in this article.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=c>(* detect_cartridge.mli *)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=n>f</span> <span class=o>:</span> <span class=n>rom_bytes</span><span class=o>:</span><span class=nn>Bigstringaf</span><span class=p>.</span><span class=n>t</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=k>module</span> <span class=nn>Cartridge_intf</span><span class=p>.</span><span class=nc>S</span><span class=o>)</span>
</span></span></code></pre></div><h2 id=integration-tests>Integration tests</h2><p>I used test ROMs and <code>ppx_expect</code> to catch regressions and to enable <em>exploratory programming</em>.</p><h3 id=what-are-test-roms>What are test ROMs</h3><p>Test ROMs are programs that test certain functionality of the emulator. For example, there are test ROMs that:</p><ul><li>Test if the basic arithmetic instructions are working as expected.</li><li>Test if the MBC1 cartridge type is adequately supported.</li></ul><p>Such test ROMs are extremely helpful when developing emulators since, unlike game ROMs, they</p><ul><li>Indicate which aspect of the emulator is failing.</li><li>Runs even if some core functionality of the emulator is missing.</li></ul><p>Test ROMs typically output the test results to the display<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>. For example, <a href=https://github.com/Gekkio/mooneye-test-suite target=_blank rel="noopener noreffer">mooneye test ROMs</a> results look like below. The text displayed in the failure case is the register dump and assertion failure information.</p><div><img src=/images/test_rom_failed.png alt="test rom failed" title=test-rom-failed>
<img src=/images/test_rom_success.png alt="test rom success" title=test-rom-success></div><h3 id=setting-up-the-tests>Setting up the tests</h3><p>Below is an example integration test implemented using a test ROM and <a href=https://github.com/janestreet/ppx_expect target=_blank rel="noopener noreffer"><code>ppx_expect</code></a>. Here is what is happening:</p><ol><li><code>M.run_test_rom_and_print_framebuffer</code> runs the given ROM and prints the final state of the screen in ASCII characters.</li><li>The printed string is matched with the <code>...</code> in <code>[%expect{|...|}]</code>.</li></ol><p>Details about <code>ppx_expect</code> can be found in <a href=https://blog.janestreet.com/testing-with-expectations target=_blank rel="noopener noreffer">this article</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=k>let</span><span class=o>%</span><span class=n>expect_test</span> <span class=s2>&#34;bits_mode.gb&#34;</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=nn>M</span><span class=p>.</span><span class=n>run_test_rom_and_print_framebuffer</span> <span class=s2>&#34;mbc1/bits_mode.gb&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>[%</span><span class=n>expect</span><span class=o>{|</span>
</span></span><span class=line><span class=cl>    <span class=mi>008</span><span class=o>:-#######-----------------------------------###---#---#----------------------------------------------------------------------------------------------------------</span>
</span></span><span class=line><span class=cl>    <span class=mi>009</span><span class=o>:----#-----####-----###-----#--------------#---#--#--#-----------------------------------------------------------------------------------------------------------</span>
</span></span><span class=line><span class=cl>    <span class=mi>010</span><span class=o>:----#----#----#---#-------####------------#---#--#-#------------------------------------------------------------------------------------------------------------</span>
</span></span><span class=line><span class=cl>    <span class=mi>011</span><span class=o>:----#----######----##------#--------------#---#--###------------------------------------------------------------------------------------------------------------</span>
</span></span><span class=line><span class=cl>    <span class=mi>012</span><span class=o>:----#----#-----------#-----#--------------#---#--#--#-----------------------------------------------------------------------------------------------------------</span>
</span></span><span class=line><span class=cl>    <span class=mi>013</span><span class=o>:----#-----####----###------##--------------###---#---#----------------------------------------------------------------------------------------------------------</span> <span class=o>|}]</span>
</span></span></code></pre></div><p>These integration tests gave me the confidence to make large code changes as the test suit would catch regressions.</p><h3 id=exploratory-programming>Exploratory programming</h3><p>Furthermore, these integration tests enabled me to implement the emulator in a <a href=https://blog.janestreet.com/repeatable-exploratory-programming/ target=_blank rel="noopener noreffer"><em>exploratory programming</em></a> style. Whenever I would implement new functionality, I would</p><ol><li>Find a test ROM that checks the functionality.</li><li>Set up <code>ppx_expect</code> tests that run the test ROM.</li><li>Run the tests and commit the failed output.</li><li>Implement the functionality.</li><li>Check if the test changed to the &ldquo;Test OK&rdquo; state.</li></ol><h2 id=compiling-to-javascript>Compiling to JavaScript</h2><p>Compiling to JavaScript was surprisingly easy thanks to <a href=https://github.com/ocsigen/js_of_ocaml target=_blank rel="noopener noreffer">js_of_ocaml</a>. I was able to get the emulator working in the browser with just a <a href=https://github.com/linoscope/CAMLBOY/commit/ac04c5d1ca39514cf7f34d19b2c5e702cc3d28c1 target=_blank rel="noopener noreffer">single commit</a>.</p><p>I used a library called <a href=https://github.com/dbuenzli/brr target=_blank rel="noopener noreffer">Brr</a> when implementing the browser UI. The great thing about Brr is that it maps JS objects to OCaml modules, unlike <code>js_of_ocaml</code> &rsquo;s built-in browser API that maps JS objects to OCaml objects, requiring some knowledge about the &ldquo;O&rdquo; in OCaml.</p><h2 id=optimization>Optimization</h2><p>Although I was able to get it working in my browser, it had one problem â€” it was unplayably slow. Below is how it looked like in the PC browser at this point, running at around 20 FPS. The actual Game Boy runs at 60 FPS, so we need to improve the performance by a factor of three.</p><div><img src=/images/before-optimize.gif alt="before optimize" title=before-optimize></div><p>Now started the journey of optimization.</p><h3 id=finding-bottlenecks-with-a-profiler>Finding bottlenecks with a profiler</h3><p>The first thing I did was use Chrome&rsquo;s profiler<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> and find out the bottlenecks. Here are the results:</p><div><img src=/images/profile-result.png alt="profile result" title=profile-result></div><p>The above show that the GPU consumes ~73% of the time, with <code>tile_data.ml</code>, <code>oam_table.ml</code>, and <code>tile_map</code> consuming 34%, 18%, and 8% of the time, respectively.</p><p>Similarly, I found that <code>timer.ml</code> and some <code>Bigstringaf</code> functions were consuming a lot of time.</p><h3 id=removing-the-bottlenecks>Removing the bottlenecks</h3><p>Now that I knew where the bottlenecks were, I worked on removing them. Since this article does not cover the parts that these changes touch, I will only list what I optimized and their results.</p><ul><li>Optimize <code>oam_table.ml</code> (<a href=https://github.com/linoscope/CAMLBOY/commit/47989b77451873202268c955bc3b650420e648e8 target=_blank rel="noopener noreffer">commit</a>):<ul><li>14fps -> 24fps</li></ul></li><li>Optimize <code>tile_data.ml</code> (<a href=https://github.com/linoscope/CAMLBOY/commit/bdc7c58c8ec1720eb38f59a64320d06f655f78f5 target=_blank rel="noopener noreffer">commit</a>):<ul><li>24fps -> 35fps</li></ul></li><li>Optimize <code>timer.ml</code> (<a href=https://github.com/linoscope/CAMLBOY/commit/db49742096db50f1f52cb72b2e5136fbd4912163 target=_blank rel="noopener noreffer">commit</a>):<ul><li>35fps -> 40fps</li></ul></li><li>Optimize <code>tile_map.ml</code> (<a href=https://github.com/linoscope/CAMLBOY/commit/7c2a6b9f694c57983da032d71a44f81f51e3cb65 target=_blank rel="noopener noreffer">commit</a>):<ul><li>40fps -> 50fps</li></ul></li><li>Use <code>Bigstringaf.unsafe_get</code> instead of <code>Bigstringaf.get</code> (<a href=https://github.com/linoscope/CAMLBOY/commit/2691a664465051eaa3b93954675e636ca4ec835a target=_blank rel="noopener noreffer">commit</a>):<ul><li>50fps -> 60fps</li></ul></li></ul><h3 id=disabling-inlining>Disabling inlining</h3><p>At this point, the emulator was running at 60 FPS on my PC browser, but only at 20~40 FPS on my phone. As I wondered what to do, I realized that the JS output from the release build was slower than the JS output from the dev build. With the <a href=https://discuss.ocaml.org/t/js-of-ocaml-output-performs-considerably-worse-when-built-with-profile-release-flag/8862 target=_blank rel="noopener noreffer">help</a> from people at discuss.ocaml.org, we found that js_of_ocaml&rsquo;s inlining was slowing down the JS performance<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>. (Update 2022-01-12: The negative impact of inlining is being addressed in <a href=https://github.com/ocsigen/js_of_ocaml/pull/1220 target=_blank rel="noopener noreffer">ocsigen/js_of_ocaml#1220</a>.)</p><p>After disabling inlining, I achieved 100 FPS on my PC and 60 FPS on my phone. Below is the gif of the emulator running in 100 FPS in the PC browser.</p><div><img src=/images/after-optimize.gif alt="after optimize" title=after-optimize></div><p>As a side note, optimizing the JS performance also improved the native performance. Below is the emulator running in ~1000 FPS in native.</p><div><img src=/images/after-optimize-native.gif alt="after optimize native" title=after-optimize-native></div><h2 id=some-benchmarks>Some benchmarks</h2><p>I implemented a <em>headless benchmarking mode</em> to run the emulator without UI. I measured the FPS in various OCaml compiler backends, and the result was as follows:<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup></p><div><img src=/images/benchmark-result.png alt="benchmark result" title=benchmark-result></div><h1 id=final-remarks>Final remarks</h1><h2 id=thoughts-on-emulator-development>Thoughts on emulator development</h2><p>I found emulator development to be similar to competitive programming. They both proceed through an iteration of the following steps:</p><ul><li>Read the specification â€” the problem statement in competitive programming and the manuals/wiki pages in emulator development.</li><li>Implement according to the specification.</li><li>Check whether the implementation satisfies the specification â€” submitting to an online judge in competitive programming and running test ROMs in emulator development.</li></ul><p>In the past, I have recommended competitive programming to people (like me) who want to code but have a hard time thinking of what to implement. In the future, I would also recommend emulator development to such people.</p><h2 id=things-i-liked-about-ocaml>Things I liked about OCaml</h2><h4 id=the-ecosystem>The ecosystem</h4><p>The ecosystem of OCaml has improved a lot since the last time I touched OCaml (around six years ago). To list a few examples:</p><ul><li>Thanks to <a href=https://dune.readthedocs.io/en/stable/ target=_blank rel="noopener noreffer">dune</a>, we now have the &ldquo;just throw the files in the directory, and the build system will do the rest&rdquo; experience, which is becoming the norm in modern programming languages.</li><li>Thanks to software such as <a href=https://github.com/ocaml/merlin target=_blank rel="noopener noreffer">Merlin</a> and <a href=https://github.com/ocaml-ppx/ocamlformat target=_blank rel="noopener noreffer">OCamlformat</a>, introducing autocomplete, code navigation, and autoformat is mostly effortless.</li><li>Thanks to <a href=https://github.com/ocaml/setup-ocaml target=_blank rel="noopener noreffer">setup-ocaml</a>, we can set up Github actions that builds and test your code by just committing a single file.</li></ul><p>If you tried OCaml a few years ago but left because of the ecosystem, you should give it another shot.</p><h4 id=doesnt-have-to-be-functional-to-be-useful>Doesn&rsquo;t have to be &ldquo;functional&rdquo; to be useful</h4><p>A functional language is often defined as &ldquo;a language that supports a programming style that uses as few side effects as possible&rdquo;, but I have always felt uncomfortable with this &ldquo;side effects&rdquo; part. I am not saying that the definition is wrong; I just never thought side effects themselves were a huge problem. An exposed mutable state is bad, but isn&rsquo;t it OK if hidden behind an abstraction?</p><p>In fact, the implementation of CAMLBOY has mutable states everywhere for performance reasons. Many modules have functions with the type <code>t -> ... -> unit</code>, which indicates modification of some mutable state. And despite this non-&ldquo;functional&rdquo; implementation, I never felt that I was missing out on the benefits of OCaml.</p><p>Maybe it&rsquo;s not that I like &ldquo;functional&rdquo; languages; I like statically typed languages with variants, pattern matching, a module system, and nice type inference.</p><h2 id=things-i-didnt-like-about-ocaml>Things I didn&rsquo;t like about OCaml</h2><h4 id=the-ecosystem-1>The ecosystem</h4><p>Although the ecosystem has significantly improved, some things still feel complex or poorly documented. For example, I had trouble resolving dependencies in a reproducible way as there seemed to be no clear instructions in the <a href=https://opam.ocaml.org/doc/Usage.html target=_blank rel="noopener noreffer">official opam document</a>. I ended up reading the source of <a href=https://github.com/ocaml/setup-ocaml target=_blank rel="noopener noreffer"><code>setup-ocaml</code></a> to find out the required commands, and the commands I found felt a little complex (we need to &ldquo;publish&rdquo; the package locally, then install the locally published package). It would be super nice if there was a single command that resolves the dependencies and builds the code in a reproducible way.</p><h4 id=the-syntactical-cost-of-depending-on-abstractions>The syntactical cost of depending on abstractions</h4><p>OCaml has a high cost of &ldquo;depending on abstractions&rdquo;. Let me illustrate what I mean with an example.</p><p>Suppose we have modules <code>A</code>, <code>B</code>, and <code>C</code> with the dependency <code>A</code> -> <code>B</code> -> <code>C</code> (<code>A</code> references <code>B</code> which references <code>C</code>), as shown below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=k>module</span> <span class=nc>A</span> <span class=o>=</span> <span class=k>struct</span> <span class=o>..</span> <span class=nn>B</span><span class=p>.</span><span class=n>foo</span> <span class=bp>()</span> <span class=o>..</span> <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>B</span> <span class=o>=</span> <span class=k>struct</span> <span class=o>..</span> <span class=nn>C</span><span class=p>.</span><span class=n>bar</span> <span class=bp>()</span> <span class=o>..</span> <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>C</span> <span class=o>=</span> <span class=k>struct</span> <span class=o>..</span> <span class=k>end</span>
</span></span></code></pre></div><p>Say you want to break the hard-coded dependency between <code>B</code> and <code>C</code>. In other words, you want to make <code>B</code> depend on the <code>C</code> &rsquo;s interface and not <code>C</code> &rsquo;s concrete implementation. You will want to do this, for example, if you want to swap <code>C</code> with a mock implementation in the unit test of <code>B</code>. You can do this with the following steps:</p><ol><li>Extract the interface of <code>C</code> into a signature called <code>C_intf</code></li><li>Define <code>B</code> as a functor that takes <code>C_int</code> as an argument</li></ol><p>The result of these changes should look like the following. Notice that <code>B</code> is now a functor that takes a module that satisfies <code>C</code>&rsquo;s interface <code>C_intf</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=k>module</span> <span class=nc>A</span>              <span class=o>=</span> <span class=k>struct</span> <span class=o>..</span> <span class=nn>B</span><span class=p>.</span><span class=n>foo</span> <span class=bp>()</span> <span class=o>..</span> <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>B</span> <span class=o>(</span><span class=nc>C</span> <span class=o>:</span> <span class=nc>C_intf</span><span class=o>)</span> <span class=o>=</span> <span class=k>struct</span> <span class=o>..</span> <span class=nn>C</span><span class=p>.</span><span class=n>bar</span> <span class=bp>()</span> <span class=o>..</span> <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>C</span>              <span class=o>=</span> <span class=k>struct</span> <span class=o>..</span> <span class=k>end</span>
</span></span></code></pre></div><p>But this won&rsquo;t compile because <code>B</code> referenced in <code>A</code> is now a functor and not a module. Therefore, we need to repeat the above steps and abstract away <code>B</code> from <code>A</code> like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-OCaml data-lang=OCaml><span class=line><span class=cl><span class=k>module</span> <span class=nc>A</span> <span class=o>(</span><span class=nc>B</span> <span class=o>:</span> <span class=nc>B_intf</span><span class=o>)</span>          <span class=o>=</span> <span class=k>struct</span> <span class=o>..</span> <span class=nn>B</span><span class=p>.</span><span class=n>foo</span> <span class=bp>()</span> <span class=o>..</span> <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>B</span> <span class=o>(</span><span class=nc>C</span> <span class=o>:</span> <span class=nc>C_intf</span><span class=o>)</span> <span class=o>:</span> <span class=nc>B_intf</span> <span class=o>=</span> <span class=k>struct</span> <span class=o>..</span> <span class=nn>C</span><span class=p>.</span><span class=n>bar</span> <span class=bp>()</span> <span class=o>..</span> <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>C</span>                       <span class=o>=</span> <span class=k>struct</span> <span class=o>..</span> <span class=k>end</span>
</span></span></code></pre></div><p>Let&rsquo;s see what happened here in detail. Any module have two types of dependencies:</p><ul><li><p>(a) How the module depends on other modules</p></li><li><p>(b) How the module is depended on by other modules</p></li></ul><p>The motivation for converting a module into a functor is to change (a), but converting a module to a functor also changes (b). In other words, <strong>converting a module to a functor not only changes how the module <em>depends on</em> other modules, but it also changes how it is <em>dependend on by</em> other modules</strong>.</p><p>This will be a bigger problem if many modules depend on <code>B</code> or if we have a deeper dependency graph.</p><p>Note that this won&rsquo;t happen in the OOP paradigm. Changing class <code>B</code> &rsquo;s constructor to take an interface <code>C_intf</code> instead of a concrete class <code>C</code> will not change the type of class <code>B</code> itself.<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup></p><p>While working on CAMLBOY, I ran into this problem when I tried to make the cartridge implementation switchable at runtime (I had the dependency graph of <code>Camlboy</code> -> <code>Bus</code> -> <code>Cartridge</code> and wanted just to decouple the <code>Bus</code> -> <code>Cartridge</code> part).</p><h1 id=recommended-materials>Recommended Materials</h1><h2 id=about-ocaml>About OCaml</h2><ul><li><a href=https://github.com/janestreet/learn-ocaml-workshop target=_blank rel="noopener noreffer">Learn OCaml Workshop</a><ul><li>I highly recommend this workshop material used (used to be used?) within Jane Street. It consists of OCaml code with holes and tests that require filling the holes to pass, so you can learn the basics of OCaml efficiently in a hands-on way. The second half of the book deals with pretty complex programs such as Snake and Lumines, so you can learn how to separate modules effectively, how you can use the build system, etc.</li></ul></li><li><a href=https://dev.realworldocaml.org/ target=_blank rel="noopener noreffer">Real World OCaml</a><ul><li>I recommend this book if you know the basic syntax of OCaml or have experience in other functional languages. It introduces the knowledge needed to write &ldquo;real world&rdquo; programs in OCaml with practical examples.</li></ul></li></ul><h2 id=about-game-boy>About Game Boy</h2><ul><li><a href="https://www.youtube.com/watch?v=HyzD8pNlpwI" target=_blank rel="noopener noreffer">The Ultimate Game Boy Talk</a><ul><li>This is a great video that explains the whole Game Boy architecture in just one hour. I&rsquo;ve watched it countless times during the course of development.</li></ul></li><li><a href=https://izik1.github.io/gbops/ target=_blank rel="noopener noreffer">gbops</a><ul><li>A table of Game Boy&rsquo;s instruction set. Information necessary for decoding instructions is summarized here.</li></ul></li><li><a href=http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf target=_blank rel="noopener noreffer">Game Boy CPU Manual</a><ul><li>CPU manual. I used this manual to implement the instructions. Note that some parts (especially around the register flags) are incorrect.</li></ul></li><li><a href=https://gbdev.io/pandocs/ target=_blank rel="noopener noreffer">Pandocs</a><ul><li>A wiki with details on how each hardware module should work. I constantly referenced this wiki while implementing GPU, Timer, etc.</li></ul></li><li><a href=https://imrannazar.com/GameBoy-Emulation-in-JavaScript target=_blank rel="noopener noreffer">Imran Nazar&rsquo;s blog</a><ul><li>A tutorial on how to implement a Game Boy emulator in JavaScript. I read it to get a rough understanding of what to implement.</li></ul></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The rough definition of &ldquo;medium/large scale code&rdquo; here is &ldquo;code that is difficult to develop without tests, and as a result, must be designed in an easily testable way&rdquo;. Writing easily testable code is a topic rarely mentioned in introductory books but is essential in practice.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>By &ldquo;advanced language features&rdquo;, I&rsquo;m thinking of OCaml&rsquo;s functors, GADTs, first-class modules, etc.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Emulators are a somewhat popular benchmark target among various languages/runtimes. For example, <a href=https://github.com/mame/optcarrot target=_blank rel="noopener noreffer">an NES emulator</a> is used in the Ruby world to benchmark different Ruby runtimes, and the Chrome team seems to have used <a href=https://github.com/chromium/octane/blob/master/gbemu-part1.js target=_blank rel="noopener noreffer">a Game Boy emulator</a> for benchmarking their JS engine.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Note that this is a sketch of my implementation and NOT a sketch of the actual Game Boy hardware. Also, I omitted components that I haven&rsquo;t implemented yet, such as APU (Audio Processing Unit), from the diagram.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>The <code>uint8</code> and <code>uint16</code> in the code are not OCaml built-in types but are types from a custom unsigned int module (<code>units.mli</code>, <code>units.ml</code>).&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>Some test ROMs, such as <a href=https://github.com/retrio/gb-test-roms target=_blank rel="noopener noreffer">blargg test roms</a>, output the test results to the serial port as ASCII characters. This enables testing the emulator even before implementing the GPU.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>Being able to use Chrome&rsquo;s profiler was a nice side effect of compiling to JS.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>This is probably because the emulator contains some long functions and the JS engine doesn&rsquo;t JIT compile when a function is too long.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>Note that we can not use this benchmark to compare the FPS with other Game Boy emulators. This is because the performance of an emulator depends significantly on how accurate it is and how much functionality it has. For example, CALMBOY does not implement the APU (Audio Processing Unit), so there is no point in comparing its FPS with emulators with APU support.&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>But OOP comes with the cost of <a href=https://en.wikipedia.org/wiki/Dynamic_dispatch target=_blank rel="noopener noreffer">dynamic dispatch</a>, which may or may not be a problem depending on your use case. Also, although OCaml supports OOP, using them might limit the readers of your code since many people (including myself) are unfamiliar with the OOP aspect of OCaml.&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-01-11</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/writing-a-game-boy-emulator-in-ocaml/index.md target=_blank>Read Markdown</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/ data-title="Writing a Game Boy Emulator in OCaml" data-via=linoscope><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on Linkedin" data-sharer=linkedin data-url=https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/><i class="fab fa-linkedin fa-fw"></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/ data-title="Writing a Game Boy Emulator in OCaml"><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="Share on Reddit" data-sharer=reddit data-url=https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/><i class="fab fa-reddit fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.111.1">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>linoscope</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:60},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-215393498-2",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-215393498-2" async></script></body></html>